/**
 * This code was automatically generated by gridtools4py:
 * the Python interface to the Gridtools library
 *
 */
#pragma once

#include <gridtools.h>
#include <stencil-composition/backend_host.h>

#include <boost/fusion/include/make_vector.hpp>



using gridtools::level;
using gridtools::arg_type;
using gridtools::range;
using gridtools::arg;

using namespace gridtools;
using namespace enumtype;


namespace {{ stencil.name|lower }}
{
//
// definition of the special regions in the vertical (k) direction
//
typedef gridtools::interval<level<0,-1>, level<1,-1> > x_interval;
typedef gridtools::interval<level<0,-2>, level<1,1> > axis;

{% block functor %}
{% endblock %}


bool test(int x, int y, int z) 
{
    int d1 = x;
    int d2 = y;
    int d3 = z;

#ifdef CUDA_EXAMPLE
#define BACKEND backend<Cuda, Naive >
#else
#ifdef BACKEND_BLOCK
#define BACKEND backend<Host, Block >
#else
#define BACKEND backend<Host, Naive >
#endif
#endif

    typedef gridtools::layout_map<2,1,0> layout_t;
    typedef gridtools::BACKEND::storage_type<double, layout_t >::type storage_type;
    //
    // input/output data fields share their buffers with NumPy arrays
    //  
    {% for arg in functor.params if arg.input -%}
    storage_type {{ arg.name }} ({{ arg.dim[0] }},
                                 {{ arg.dim[1] }},
                                 {{ arg.dim[2] }},
                                 -3.5,
                                 std::string ("{{ arg.name }}"));
    {% endfor %}
    {% for arg in functor.params if arg.output -%}
    storage_type {{ arg.name }} ({{ arg.dim[0] }},
                                 {{ arg.dim[1] }},
                                 {{ arg.dim[2] }},
                                 1.5,
                                 std::string ("{{ arg.name }}"));
    {% endfor %}

    // Definition of placeholders. The order of them reflect the order the user will deal with them
    // especially the non-temporary ones, in the construction of the domain
    typedef arg<0, storage_type > p_in;
    typedef arg<1, storage_type > p_out;

    // An array of placeholders to be passed to the domain
    // I'm using mpl::vector, but the final API should look slightly simpler
    typedef boost::mpl::vector<p_in, p_out> arg_type_list;

    // construction of the domain.
    // The domain is the physical domain of the problem, with all the physical
    // fields that are used, temporary and not.
    // It must be noted that the only fields to be passed to the constructor 
    // are the non-temporary. The order in which they have to be passed is the
    // order in which they appear scanning the placeholders in order. 
    // (I don't particularly like this)
    gridtools::domain_type<arg_type_list> domain
        (boost::fusion::make_vector(&in, &out));

    // Definition of the physical dimensions of the problem.
    // The constructor takes the horizontal plane dimensions,
    // while the vertical ones are set according the the axis property soon after
    // gridtools::coordinates<axis> coords(2,d1-2,2,d2-2);
    int di[5] = {0, 0, 0, d1, d1};
    int dj[5] = {0, 0, 0, d2, d2};

    gridtools::coordinates<axis> coords(di, dj);
    coords.value_list[0] = 0;
    coords.value_list[1] = d3-1;

    /*
      Here we do lot of stuff
      1) We pass to the intermediate representation ::run function the description
      of the stencil, which is a multi-stage stencil (mss)
      The mss includes (in order of execution) a laplacian, two fluxes which are independent
      and a final step that is the out_function
      2) The logical physical domain with the fields to use
      3) The actual domain dimensions
     */

// \todo simplify the following using the auto keyword from C++11
#ifdef __CUDACC__
    gridtools::computation* copy =
#else
        boost::shared_ptr<gridtools::computation> copy =
#endif
      gridtools::make_computation<gridtools::BACKEND, layout_t>
        (
            gridtools::make_mss // mss_descriptor
            (
                execute<forward>(),
                gridtools::make_esf<{{ functor.name }}>(p_in(), p_out()) // esf_descriptor
                ),
            domain, coords
            );

    copy->ready();

    copy->steady();
    domain.clone_to_gpu();

    copy->run();

    copy->finalize();

#ifdef CUDA_EXAMPLE
    out.m_data.update_cpu();
#endif

    out.print_value(0,0,0);
    out.print_value(511,511,0);
    out.print_value(511,0,59);
    out.print_value(0,511,59);
    out.print_value(511,511,59);

    return  out(0,0,0)==0. && out(511,511,0)==1022. && out(511,0,59)==570. && out(0,511,59)==570. && out(511,511,59)==1081.;
}

} // namespace {{ stencil.name|lower }}

/**
 * This code was automatically generated by gridtools4py:
 * the Python interface to the Gridtools library
 *
 */
#pragma once

#include <gridtools.h>
#include <common/defs.h>
#include <stencil-composition/backend_host.h>

#include <boost/fusion/include/make_vector.hpp>



using gridtools::level;
using gridtools::arg_type;
using gridtools::range;
using gridtools::arg;

using namespace gridtools;
using namespace enumtype;


namespace {{ stencil.name|lower }}
{
//
// definition of the special regions in the vertical (k) direction
//
typedef gridtools::interval<level<0,-1>, level<1,-1> > x_interval;
typedef gridtools::interval<level<0,-2>, level<1,1> > axis;

{% block functor %}
{% endblock %}


bool test (uint_t d1, uint_t d2, uint_t d3,
    {## 
     ## Pointers to NumPy arrays passed from Python 
     ##}
    {%- for name,arg in stencil.symbols.items ( ) if stencil.symbols.is_parameter (name) or
                                                     stencil.symbols.is_temporary (name) -%}
        void * {{ name }}_buff
        {%- if not loop.last -%}
            ,
        {%- endif -%}
    {%- endfor -%})
{
#ifdef CUDA_EXAMPLE
#define BACKEND backend<Cuda, Naive >
#else
#ifdef BACKEND_BLOCK
#define BACKEND backend<Host, Block >
#else
#define BACKEND backend<Host, Naive >
#endif
#endif

    //
    // Fortran-like memory layout
    //
    //typedef gridtools::layout_map<2,1,0> layout_t;
    
    //
    // C-like memory layout
    //
    typedef gridtools::layout_map<0,1,2> layout_t;
    typedef gridtools::BACKEND::storage_type<double, layout_t >::type storage_type;

    {## 
     ## Declaration of temporary data fields
     ##}
    {% for name,arg in stencil.symbols.items ( ) if stencil.symbols.is_temporary (name) %}
        {% if loop.first %}
    //
    // temporary data fields share their buffers with NumPy arrays
    //
        {% endif -%}
    storage_type {{ name }} ({{ arg.shape|join_with_prefix('(uint_t) ')|join(',') }},
                                 (double *) {{ name }}_buff,
                                 0.0,
                                 std::string ("{{ name }}"));
    {% endfor %}


    {## 
     ## Declaration of input data fields
     ##}
    {% for name,arg in functor.params.items ( ) if arg.input -%}
        {% if loop.first %}
    //
    // input data fields share their buffers with NumPy arrays
    //  
        {% endif %}
    storage_type {{ name }} ({{ arg.dim|join_with_prefix('(uint_t) ')|join(',') }},
                                 (double *) {{ name }}_buff,
                                 1.0,
                                 std::string ("{{ name }}"));
    {% endfor %}


    {## 
     ## Declaration of output data fields
     ##}
    {% for name,arg in functor.params.items ( ) if arg.output -%}
        {% if loop.first %}
    //
    // output data fields also share their buffers with NumPy arrays
    //  
        {% endif -%}
    storage_type {{ name }} ({{ arg.dim|join_with_prefix('(uint_t) ')|join(',') }},
                                 (double *) {{ name }}_buff,
                                 2.0,
                                 std::string ("{{ name }}"));
    {% endfor %}

    // 
    // place-holder definition: their order reflect matches the stencil
    // parameters, especially the non-temporary ones, during the construction
    // of the domain
    //
    {% for name,arg in functor.params.items ( ) -%}
    typedef arg<{{ arg.id }}, storage_type> p_{{ arg.name }};
    {% endfor -%}


    // An array of placeholders to be passed to the domain
    // I'm using mpl::vector, but the final API should look slightly simpler
    typedef boost::mpl::vector<{{ functor.params.keys ( )|join_with_prefix("p_")|join(',') }}> arg_type_list;


    //
    // construction of the domain.
    // The domain is the physical domain of the problem, with all the physical
    // fields that are used, temporary and not.
    // It must be noted that the only fields to be passed to the constructor 
    // are the non-temporary. The order in which they have to be passed is the
    // order in which they appear scanning the placeholders in order. 
    // (I don't particularly like this)
    //
    gridtools::domain_type<arg_type_list> domain
        (boost::fusion::make_vector ({{ functor.params.keys ( )|join_with_prefix('&')|join(',') }}));

    //
    // definition of the physical dimensions of the problem.
    // The constructor takes the horizontal plane dimensions,
    // while the vertical ones are set according the the axis property soon 
    // after this:
    //
    //      gridtools::coordinates<axis> coords(2,d1-2,2,d2-2);
    //
    uint_t di[5] = {0, 0, 0, d1, d1};
    uint_t dj[5] = {0, 0, 0, d2, d2};

    gridtools::coordinates<axis> coords(di, dj);
    coords.value_list[0] = 0;
    coords.value_list[1] = d3-1;

    //
    // Here we do a lot of stuff
    //
    // 1) we pass to the intermediate representation ::run function the 
    // description of the stencil, which is a multi-stage stencil (mss);
    // 2) the logical physical domain with the fields to use;
    // 3) the actual domain dimensions
    //
    boost::shared_ptr<gridtools::computation> comp_{{ stencil.name|lower }} =
      gridtools::make_computation<gridtools::BACKEND, layout_t>
        (
            gridtools::make_mss
            (
                execute<forward>(),
                gridtools::make_esf<{{ functor.name }}>({{ functor.params.keys ( )|join_with_prefix("p_")|join('(),') }}())
                ),
            domain, coords
            );

    comp_{{ stencil.name|lower }}->ready();
    comp_{{ stencil.name|lower }}->steady();
    
    domain.clone_to_gpu ( );

    comp_{{ stencil.name|lower }}->run();
    comp_{{ stencil.name|lower }}->finalize();

{% for name,arg in functor.params.items ( ) if arg.output %}
#ifdef CUDA_EXAMPLE
    {{ name }}.m_data.update_cpu();
#endif

    {{ name }}.print_value(0,0,0);
    {{ name }}.print_value(511,511,0);
    {{ name }}.print_value(511,0,59);
    {{ name }}.print_value(0,511,59);
    {{ name }}.print_value(511,511,59);

    return  {{ name }}(0,0,0)==0. &&
            {{ name }}(511,511,0)==1022. && 
            {{ name }}(511,0,59)==570. && 
            {{ name }}(0,511,59)==570. &&
            {{ name }}(511,511,59)==1081.;
{% endfor %}
}

} // namespace {{ stencil.name|lower }}


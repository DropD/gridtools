/**
 * This code was automatically generated by gridtools4py:
 * the Python interface to the Gridtools library
 *
 */
#pragma once

#include <gridtools.h>
#include <common/defs.h>
#include <stencil-composition/backend_host.h>

#include <boost/fusion/include/make_vector.hpp>



using gridtools::level;
using gridtools::arg_type;
using gridtools::range;
using gridtools::arg;

using namespace gridtools;
using namespace enumtype;


namespace copystencil
{
//
// definition of the special regions in the vertical (k) direction
//
typedef gridtools::interval<level<0,-1>, level<1,-1> > x_interval;
typedef gridtools::interval<level<0,-2>, level<1,1> > axis;



//
// definition of the operators that compose the multistage stencil:
// this is extracted from the AST analysis of the loop operations
// in Python, using the 'kernel' function as a starting point
//
struct kernel_functor
{
    //
    // the number of arguments the function receives in Python,
    // excluding the 'self' parameter
    //
    static const int n_args = 2;

    //
    // the input parameters of the stencil should be 'const'
    //
    typedef const arg_type<1> in_data;


    //
    // the output parameters of the stencil
    //
    typedef arg_type<0> out_data;


    //
    // the complete list of arguments of this functor
    //
    typedef boost::mpl::vector<out_data,in_data> arg_list;

    //
    // the operation of this functor
    //
    template <typename Domain>
    GT_FUNCTION
    static void Do(Domain const & dom, x_interval)
    {
        dom(out_data( )) = dom(in_data( ));

    }
};


//
// the following operator is provided for debugging purposes
//
std::ostream& operator<<(std::ostream& s, kernel_functor const)
{
    return s << "kernel_functor";
}




bool test (uint_t d1, uint_t d2, uint_t d3, void *out_buff, void *in_buff)
{
#ifdef CUDA_EXAMPLE
#define BACKEND backend<Cuda, Naive >
#else
#ifdef BACKEND_BLOCK
#define BACKEND backend<Host, Block >
#else
#define BACKEND backend<Host, Naive >
#endif
#endif

    //
    // Fortran-like memory layout
    //
    //typedef gridtools::layout_map<2,1,0> layout_t;

    //
    // C-like memory layout
    //
    typedef gridtools::layout_map<0,1,2> layout_t;
    typedef gridtools::BACKEND::storage_type<double, layout_t >::type storage_type;
    //
    // input/output data fields share their buffers with NumPy arrays
    //
    storage_type in_data ((uint_t) 6,(uint_t) 6,(uint_t) 6,
                                 (double *) in_buff,
                                 -3.5,
                                 std::string ("in_data"));

    storage_type out_data ((uint_t) 6,(uint_t) 6,(uint_t) 6,
                                 (double *) out_buff,
                                 1.5,
                                 std::string ("out_data"));


    //
    // place-holder definition: their order reflect matches the stencil
    // parameters, especially the non-temporary ones, during the construction
    // of the domain
    //
    typedef arg<0, storage_type> p_out_data;
    typedef arg<1, storage_type> p_in_data;
    // An array of placeholders to be passed to the domain
    // I'm using mpl::vector, but the final API should look slightly simpler
    typedef boost::mpl::vector<p_out_data,p_in_data> arg_type_list;


    //
    // construction of the domain.
    // The domain is the physical domain of the problem, with all the physical
    // fields that are used, temporary and not.
    // It must be noted that the only fields to be passed to the constructor
    // are the non-temporary. The order in which they have to be passed is the
    // order in which they appear scanning the placeholders in order.
    // (I don't particularly like this)
    //
    gridtools::domain_type<arg_type_list> domain
        (boost::fusion::make_vector (&out_data,&in_data));

    //
    // definition of the physical dimensions of the problem.
    // The constructor takes the horizontal plane dimensions,
    // while the vertical ones are set according the the axis property soon
    // after this:
    //
    //      gridtools::coordinates<axis> coords(2,d1-2,2,d2-2);
    //
    uint_t di[5] = {0, 0, 0, d1, d1};
    uint_t dj[5] = {0, 0, 0, d2, d2};

    gridtools::coordinates<axis> coords(di, dj);
    coords.value_list[0] = 0;
    coords.value_list[1] = d3-1;

    /*
      Here we do lot of stuff
      1) We pass to the intermediate representation ::run function the description
      of the stencil, which is a multi-stage stencil (mss)
      The mss includes (in order of execution) a laplacian, two fluxes which are independent
      and a final step that is the out_function
      2) The logical physical domain with the fields to use
      3) The actual domain dimensions
     */

      boost::shared_ptr<gridtools::computation> comp_copystencil =
      gridtools::make_computation<gridtools::BACKEND, layout_t>
        (
            gridtools::make_mss
            (
                execute<forward>(),
                gridtools::make_esf<kernel_functor>(p_out_data(),p_in_data())
                ),
            domain, coords
            );

    comp_copystencil->ready();
    comp_copystencil->steady();

    domain.clone_to_gpu ( );

    comp_copystencil->run();
    comp_copystencil->finalize();


#ifdef CUDA_EXAMPLE
    out_data.m_data.update_cpu();
#endif

    in_data.print();
    out_data.print();
    // out_data.print_value(0,0,0);
    // out_data.print_value(5,5,0);
    // out_data.print_value(5,0,5);
    // out_data.print_value(0,5,5);
    // out_data.print_value(5,5,5);

    return true;

}

} // namespace copystencil
